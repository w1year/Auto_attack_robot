// 替换 src/camera/mvs_camera.cpp 中的 convertToMat 函数

cv::Mat MVSCamera::convertToMat(unsigned char* data, int width, int height, int pixelType) {
    cv::Mat frame;
    
#ifdef MVS_SDK_ENABLED
#ifdef OPENCV_CUDA_ENABLED
    // 检查CUDA是否可用（只检查一次）
    if (!s_cudaChecked) {
        try {
            int deviceCount = cv::cuda::getCudaEnabledDeviceCount();
            s_cudaAvailable = (deviceCount > 0);
            if (s_cudaAvailable) {
                LOG_INFO("CUDA加速已启用，Bayer转换将使用GPU加速");
            } else {
                LOG_WARNING("CUDA设备数量为0，Bayer转换将使用CPU");
            }
        } catch (...) {
            s_cudaAvailable = false;
            LOG_WARNING("CUDA检查异常，Bayer转换将使用CPU");
        }
        s_cudaChecked = true;
    }
#endif

    switch (pixelType) {
        //以此类推，处理所有Bayer格式
        case PixelType_Gvsp_BayerRG8: {
            cv::Mat bayerImg(height, width, CV_8UC1, data);
#ifdef OPENCV_CUDA_ENABLED
            if (s_cudaAvailable) {
                // CUDA加速：使用GPU进行Bayer转换
                cv::cuda::GpuMat gpuBayer(bayerImg);
                cv::cuda::GpuMat gpuBGR;
                
                // 注意：OpenCV默认输出BGR，这正是我们需要用于显示和OpenCV处理的格式
                // 不需要再手动交换B和R通道，除非你的模型明确需要RGB输入且不进行预处理
                cv::cuda::cvtColor(gpuBayer, gpuBGR, cv::COLOR_BayerRG2BGR, 0, s_cudaStream);
                
                gpuBGR.download(frame, s_cudaStream);
                s_cudaStream.waitForCompletion();
            } else {
#endif
            // CPU版本
            cv::cvtColor(bayerImg, frame, cv::COLOR_BayerRG2BGR);
#ifdef OPENCV_CUDA_ENABLED
            }
#endif
            break;
        }
        case PixelType_Gvsp_BayerBG8: {
            cv::Mat bayerImg(height, width, CV_8UC1, data);
#ifdef OPENCV_CUDA_ENABLED
            if (s_cudaAvailable) {
                cv::cuda::GpuMat gpuBayer(bayerImg);
                cv::cuda::GpuMat gpuBGR;
                cv::cuda::cvtColor(gpuBayer, gpuBGR, cv::COLOR_BayerBG2BGR, 0, s_cudaStream);
                gpuBGR.download(frame, s_cudaStream);
                s_cudaStream.waitForCompletion();
            } else {
#endif
            cv::cvtColor(bayerImg, frame, cv::COLOR_BayerBG2BGR);
#ifdef OPENCV_CUDA_ENABLED
            }
#endif
            break;
        }
        case PixelType_Gvsp_BayerGB8: {
            cv::Mat bayerImg(height, width, CV_8UC1, data);
#ifdef OPENCV_CUDA_ENABLED
            if (s_cudaAvailable) {
                cv::cuda::GpuMat gpuBayer(bayerImg);
                cv::cuda::GpuMat gpuBGR;
                cv::cuda::cvtColor(gpuBayer, gpuBGR, cv::COLOR_BayerGB2BGR, 0, s_cudaStream);
                gpuBGR.download(frame, s_cudaStream);
                s_cudaStream.waitForCompletion();
            } else {
#endif
            cv::cvtColor(bayerImg, frame, cv::COLOR_BayerGB2BGR);
#ifdef OPENCV_CUDA_ENABLED
            }
#endif
            break;
        }
        case PixelType_Gvsp_BayerGR8: {
            cv::Mat bayerImg(height, width, CV_8UC1, data);
#ifdef OPENCV_CUDA_ENABLED
            if (s_cudaAvailable) {
                cv::cuda::GpuMat gpuBayer(bayerImg);
                cv::cuda::GpuMat gpuBGR;
                cv::cuda::cvtColor(gpuBayer, gpuBGR, cv::COLOR_BayerGR2BGR, 0, s_cudaStream);
                gpuBGR.download(frame, s_cudaStream);
                s_cudaStream.waitForCompletion();
            } else {
#endif
            cv::cvtColor(bayerImg, frame, cv::COLOR_BayerGR2BGR);
#ifdef OPENCV_CUDA_ENABLED
            }
#endif
            break;
        }
        case PixelType_Gvsp_Mono8: {
            cv::Mat monoImg(height, width, CV_8UC1, data);
            cv::cvtColor(monoImg, frame, cv::COLOR_GRAY2BGR);
            break;
        }
        case PixelType_Gvsp_RGB8_Packed:
        case PixelType_Gvsp_BGR8_Packed: {
            cv::Mat rgbImg(height, width, CV_8UC3, data);
            if (pixelType == PixelType_Gvsp_RGB8_Packed) {
                cv::cvtColor(rgbImg, frame, cv::COLOR_RGB2BGR);
            } else {
                frame = rgbImg.clone();
            }
            break;
        }
        default:
            LOG_ERROR("不支持的像素格式: " + intToHex(static_cast<unsigned int>(pixelType)));
            frame = cv::Mat::zeros(height, width, CV_8UC3);
            break;
    }
#else
    frame = cv::Mat::zeros(height, width, CV_8UC3);
#endif
    
    return frame;
}



// 替换 src/main.cpp 中的 patrolThread 函数

void patrolThread(GimbalController* gimbal) {
    // 设置线程优先级和名称
    ThreadOptimizer::setThreadName("PatrolThread");
    ThreadOptimizer::setCurrentThreadPriority(ThreadOptimizer::NORMAL, -1);
    
    LOG_INFO("启动云台巡航线程");
    
    // 巡航参数
    const int centerAngle = 15000;  // 中心位置
    const int patrolRange = 13000;  // 巡航范围
    const int leftLimit = centerAngle + patrolRange;
    const int rightLimit = centerAngle - patrolRange;
    
    // 巡航动态参数
    int patrolSpeed = 50;
    double patrolDelay = 0.03; 
    
    int currentAngle = centerAngle;
    int direction = 1;  // 1:向左, -1:向右
    
    // 角度输出控制
    auto lastAngleLogTime = std::chrono::steady_clock::now();
    const auto angleLogInterval = std::chrono::seconds(1);
    
    while (g_running.load()) {
        try {
            // 检查点1: 如果已锁定目标或未启用巡航，直接进入等待，释放CPU
            if (!g_patrolEnabled.load() || g_targetLock.load()) {
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                // 更新当前角度变量，防止重新接管时跳变
                currentAngle = g_currentYawAngle.load();
                continue;
            }

            // 计算新角度逻辑 (纯计算，不涉及IO，不需要锁)
            int distanceToLeft = leftLimit - currentAngle;
            int distanceToRight = currentAngle - rightLimit;
            
            // 简单的加减速逻辑
            int currentSpeed = patrolSpeed;
            if (direction > 0 && distanceToLeft < 500) {
                 currentSpeed = std::max(30, static_cast<int>(patrolSpeed * (distanceToLeft / 500.0)));
            } else if (direction < 0 && distanceToRight < 500) {
                 currentSpeed = std::max(30, static_cast<int>(patrolSpeed * (distanceToRight / 500.0)));
            }
            
            int nextAngle = currentAngle + currentSpeed * direction;
            
            // 边界检查
            if (nextAngle >= leftLimit) {
                nextAngle = leftLimit;
                direction = -1;
            } else if (nextAngle <= rightLimit) {
                nextAngle = rightLimit;
                direction = 1;
            }
            
            // 关键修改: 在执行硬件IO和更新全局状态前，再次检查锁定状态
            // 使用互斥锁保护对云台的写操作
            {
                std::lock_guard<std::mutex> lock(g_gimbalMutex);
                
                // 检查点2: 再次确认是否被检测线程抢占
                if (!g_targetLock.load()) {
                    currentAngle = nextAngle;
                    gimbal->setYawAngle(currentAngle);
                    g_currentYawAngle = currentAngle; // 更新全局状态
                    
                    // 日志输出
                    auto now = std::chrono::steady_clock::now();
                    if (now - lastAngleLogTime >= angleLogInterval) {
                        // LOG_INFO("巡航中: " + std::to_string(currentAngle)); // 减少日志刷屏
                        lastAngleLogTime = now;
                    }
                } else {
                    // 如果被锁定了，立即放弃本次移动
                    currentAngle = g_currentYawAngle.load();
                }
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(patrolDelay * 1000)));
            
        } catch (const std::exception& e) {
            LOG_ERROR("巡航线程异常: " + std::string(e.what()));
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }
    
    LOG_INFO("云台巡航线程已停止");
}


// 替换 src/serial/serial_comm.cpp 中的 closePort 函数 (Linux部分)

#ifndef _WIN32
void SerialComm::closePort() {
    // 将void* 转换回 int
    int fd = static_cast<int>(reinterpret_cast<intptr_t>(m_handle));
    
    if (fd >= 0) {
        ::close(fd);
    }
    
    // 关键修复: 显式将句柄重置为 -1，防止悬空句柄
    // 在 Linux 下，-1 代表无效的 fd
    m_handle = reinterpret_cast<void*>(static_cast<intptr_t>(-1));
}
#endif
